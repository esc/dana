//
// Copyright (C) 2007 Nicolas Rougier
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 2 of the
// License, or (at your option) any later version.
//
// $Id$

#include "array_bar.h"

using namespace boost::python::numeric;
using namespace glpython::objects;


//_____________________________________________________________________ArrayBar
ArrayBar::ArrayBar (object array,
                    core::ColormapPtr colormap,
                    float alpha,
                    object frame) : Array (array, colormap, alpha, frame)
{}


//____________________________________________________________________~ArrayBar
ArrayBar::~ArrayBar (void)
{}


//_______________________________________________________________________update
void
ArrayBar::render (void)
{
    if (!tex_id)
        initialize();

    GLint mode;
    glGetIntegerv (GL_RENDER_MODE, &mode);

    int d1 = array->dimensions[0];
    int d0 = array->dimensions[1];
    float x, y, w, h;
    try {
        x = extract< float >(this->frame[0])();
        y = extract< float >(this->frame[1])();
        w = extract< float >(this->frame[2])();
        h = extract< float >(this->frame[3])();
    } catch (...) {
        PyErr_Print();
        return;
    }

    glDisable (GL_BLEND);
    glPushAttrib (GL_ENABLE_BIT);
//    glEnable (GL_LIGHTING);
    glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
    
    int jj = 0;
    float dx = float(w)/float(d0);
    float dy = float(h)/float(d1);
    float dz = dx*10;
    int dtype = this->array->descr->type_num;
    
    for (int j=0; j<d1; j++) {
        int ii = 0;
        for (int i=0; i<d0; i++) {
            float v = 0;
            if (dtype == NPY_FLOAT)
                v = *(float *)(array->data + jj + ii);
            else if (dtype ==  NPY_DOUBLE)
                v = *(double *)(array->data + jj + ii);
            else if (dtype ==  NPY_LONGDOUBLE)
                v = *(long double *)(array->data + jj + ii);
            glColor4fv (colormap->color(v).data);
            glMaterialfv (GL_FRONT, GL_AMBIENT_AND_DIFFUSE, colormap->color(v).data);
            if (mode == GL_SELECT)
                glLoadName (id + j*d0+i);
            if (v > 0)
                cube (-0.5+x+i*dx, -0.5+y+(d1-1-j)*dy, 0, dx,dy,v*dz);
            else
                cube (-0.5+x+i*dx, -0.5+y+(d1-1-j)*dy, v*dz, dx,dy, -v*dz);                
            ii += array->strides[1];
        }
        jj += array->strides[0];
    }
    if (mode == GL_SELECT)
        glLoadName (0);

    glDisable (GL_LIGHTING);
    glPolygonMode (GL_FRONT_AND_BACK, GL_LINE);
    glDisable (GL_POLYGON_OFFSET_FILL);

    // Border
    glColor3f (0,0,0);
    glBegin (GL_QUADS);
    glVertex2f (-0.5+x,   -0.5+y);
    glVertex2f (-0.5+x+w, -0.5+y);
    glVertex2f (-0.5+x+w, -0.5+y+h);
    glVertex2f (-0.5+x,   -0.5+y+h);
    glEnd ();
 
    glPopAttrib();
}

//_________________________________________________________________________cube
void
ArrayBar::cube (float x, float y, float z, float dx, float dy, float dz)
{
    glBegin (GL_QUADS);

    // Top Face (z)
    glNormal3f ( 0.0f,  0.0f,  1.0f);
    glVertex3f (    x,     y,  z+dz);
    glVertex3f ( x+dx,     y,  z+dz);
    glVertex3f ( x+dx,  y+dy,  z+dz);
    glVertex3f (    x,  y+dy,  z+dz);

    // Bottom Face (-z)
    glNormal3f ( 0.0f,  0.0f, -1.0f);
    glVertex3f (    x,     y,     z);
    glVertex3f (    x,  y+dy,     z);
    glVertex3f ( x+dx,  y+dy,     z);
    glVertex3f ( x+dx,     y,     z);

    // Front face (x)
    glNormal3f ( 1.0f,  0.0f,  0.0f);
    glVertex3f ( x+dx,     y,     z);
    glVertex3f ( x+dx,  y+dy,     z);
    glVertex3f ( x+dx,  y+dy,  z+dz);
    glVertex3f ( x+dx,     y,  z+dz);

    // Rear Face (-x)
    glNormal3f (-1.0f,  0.0f,  0.0f);
    glVertex3f (    x,     y,     z);
    glVertex3f (    x,     y,  z+dz);
    glVertex3f (    x,  y+dy,  z+dz);
    glVertex3f (    x,  y+dy,     z);

    // Left Face (y)
    glNormal3f ( 0.0f,  1.0f,  0.0f);
    glVertex3f (    x,     y,     z);
    glVertex3f (    x,     y,  z+dz);
    glVertex3f ( x+dx,     y,  z+dz);
    glVertex3f ( x+dx,     y,     z);

    // Right Face (-y)
    glNormal3f ( 0.0f, -1.0f,  0.0f);
    glVertex3f (    x,  y+dy,     z);
    glVertex3f ( x+dx,  y+dy,     z);
    glVertex3f ( x+dx,  y+dy,  z+dz);
    glVertex3f (    x,  y+dy,  z+dz);
    glEnd();
}

//________________________________________________________________python_export
void
ArrayBar::python_export (void)
{
    using namespace boost::python;
    register_ptr_to_python< boost::shared_ptr<ArrayBar> >();
    import_array();
    numeric::array::set_module_and_type ("numpy", "ndarray");  


    class_<ArrayBar, bases< Array> > ("ArrayBar",
    "======================================================================\n"
    "                                                                      \n"
    "======================================================================\n",
    init<object, optional <core::ColormapPtr, float, object> > ())
    ;
}

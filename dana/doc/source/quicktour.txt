.. _quick-tour:

==========
Quick tour
==========

As a quick tour of DANA, let's implement the `game of life
<http://en.wikipedia.org/wiki/Conway's_Game_of_Life>`_ by John Conway using
pure python, numpy and dana to illustrate some concepts.

The game of Life
================

**From wikipedia**:

The Game of Life, also known simply as Life, is a cellular automaton devised by
the British mathematician John Horton Conway in 1970.  It is the best-known
example of a cellular automaton. The "game" is actually a zero-player game,
meaning that its evolution is determined by its initial state, needing no input
from human players. One interacts with the Game of Life by creating an initial
configuration and observing how it evolves.

The universe of the Game of Life is an infinite two-dimensional orthogonal grid
of square cells, each of which is in one of two possible states, live or
dead. Every cell interacts with its eight neighbours, which are the cells that
are directly horizontally, vertically, or diagonally adjacent. At each step in
time, the following transitions occur:

1. Any live cell with fewer than two live neighbours dies, as if by needs
   caused by underpopulation.
2. Any live cell with more than three live neighbours dies, as if by
   overcrowding.
3. Any live cell with two or three live neighbours lives, unchanged, to the
   next generation.
4. Any dead cell with exactly three live neighbours becomes a live cell.

The initial pattern constitutes the 'seed' of the system.  The first generation
is created by applying the above rules simultaneously to every cell in the seed
â€“ births and deaths happen simultaneously, and the discrete moment at which
this happens is sometimes called a tick. (In other words, each generation is a
pure function of the one before.)  The rules continue to be applied repeatedly
to create further generations.


.. _quick-tour-python:

The way of python
=================

In pure python, we can code the Game of Life using a list of lists 
representing the board where cells are supposed to evolve:

.. code-block:: pycon

   >>> Z = [[0,0,0,0,0,0],
            [0,0,0,1,0,0],
            [0,1,0,1,0,0],
            [0,0,1,1,0,0],
            [0,0,0,0,0,0],
            [0,0,0,0,0,0]]

This board possesses a ``0`` border that allows to accelerate things a bit by
avoiding to have specific tests for borders when counting the number of
neighbours. To iterate one step in time, we simply count the number of
neighbours for each internal cell and we update the whole board according to
the Game of Life rules:

.. code-block:: python

   def iterate(Z):
       shape = len(Z), len(Z[0])
       N  = [[0,]*(shape[0]+2)  for i in range(shape[1]+2)]
       # Compute number of neighbours for each cell
       for x in range(1,shape[0]-1):
           for y in range(1,shape[1]-1):
               N[x][y] = Z[x-1][y-1]+Z[x][y-1]+Z[x+1][y-1] \
                       + Z[x-1][y]            +Z[x+1][y]   \
                       + Z[x-1][y+1]+Z[x][y+1]+Z[x+1][y+1]
       # Update cells
       for x in range(1,shape[0]-1):
           for y in range(1,shape[1]-1):
               if Z[x][y] == 0 and N[x][y] == 3:
                   Z[x][y] = 1
               elif Z[x][y] == 1 and not N[x][y] in [2,3]:
                   Z[x][y] = 0
       return Z

Finally, we iterate 4 steps in time and we check the `glider
<http://en.wikipedia.org/wiki/Glider_(Conway's_Life)>`_ has glided one step
down and right:

.. code-block:: pycon

   >>> display(Z)
   0 0 1 0
   1 0 1 0
   0 1 1 0
   0 0 0 0
   >>> for i in range(4):
           iterate(Z)
   >>> display(Z)
   0 0 0 0
   0 0 0 1
   0 1 0 1
   0 0 1 1


Sources
-------

`game-of-life_python.py <_static/game-of-life_python.py>`_



.. _quick-tour-numpy:

The way of numpy
================

Using numpy, we can benefit from vectorized computation and accelerates things
a lot. The board can now be represented using a numpy array:

.. code-block:: pycon

   >>> import numpy
   >>> Z = numpy.array ([[0,0,0,0,0,0],
                         [0,0,0,1,0,0],
                         [0,1,0,1,0,0],
                         [0,0,1,1,0,0],
                         [0,0,0,0,0,0],
                         [0,0,0,0,0,0]])

This board possesses a ``0`` border that allows to accelerate things a bit by
avoiding to have specific tests for borders when counting the number of
neighbours. To iterate one step in time, we count the number of neighbours for
all internal cells at once and we update the whole board according to the Game
of Life rules:

.. code-block:: python

   def iterate(Z):
       # find number of neighbours that each square has
       N = numpy.zeros(Z.shape)
       N[1:, 1:] += Z[:-1, :-1]
       N[1:, :-1] += Z[:-1, 1:]
       N[:-1, 1:] += Z[1:, :-1]
       N[:-1, :-1] += Z[1:, 1:]
       N[:-1, :] += Z[1:, :]
       N[1:, :] += Z[:-1, :]
       N[:, :-1] += Z[:, 1:]
       N[:, 1:] += Z[:, :-1]
       # a live cell is killed if it has fewer than 2 or more than 3 neighbours.
       part1 = ((Z == 1) & (N < 4) & (N > 1)) 
       # a new cell forms if a square has exactly three members
       part2 = ((Z == 0) & (N == 3))
       return (part1 | part2).astype(int)

Finally, we iterate 4 steps in time and we check the `glider
<http://en.wikipedia.org/wiki/Glider_(Conway's_Life)>`_ has glided one step
down and right:

.. code-block:: pycon

   >>> print Z[1:-1]
   [[0 0 1 0]
    [1 0 1 0]
    [0 1 1 0]
    [0 0 0 0]]
   >>> for i in range(4):
           iterate(Z)
   >>> print Z[1:-1]
   [[0 0 0 0]
    [0 0 0 1]
    [0 1 0 1]
    [0 0 1 1]]


Sources
-------

`game-of-life_numpy.py <_static/game-of-life_numpy.py>`_


.. _quick-tour-dana:

The way of dana
===============

The first thing to do is to create a group for holding our cells:

.. code-block:: python

   >>> import numpy, dana
   >>> Z = dana.group([[0,0,1,0],
                       [1,0,1,0],
                       [0,1,1,0],
                       [0,0,0,0]])

This group is now made of 4x4 cells, each of them having a single integer value
named *V* (this is the default name).  Each cell needs to be connected to its
immediate neighbours. This can be done by using a connection kernel to connect
*Z* to itself:

.. code-block:: python

   >>> Z.connect(Z.V, numpy.array([[1,1,1],
                                   [1,0,1],
                                   [1,1,1]]), 'N')

Cells are now linked to their immediate neighbours using a connection named
*N*. This connection represents the weighted sum of cell *state* activity and
weight links.  Since link values are either 0 or 1 (because the kernel is made
of 0 and 1) and cell states are either 0 or 1 , the weighted sum actually
represents the number of live cells in the immediate neighboorhood. Using this
information, we can now define how the *state* variable evolve between time *t*
and *t+dt* given that:

* *V* represents the current state of a cell
* *N* is the number of active neighbours

According to the game of life rules, we know that:

* every cell with less than 1 neighbours must die: (N<1.5)
* every cell with more than 4 neighbours must die: (N>3.5)
* every dead cell with less than 3 neighbours must die: (N<2.5)*(1-state)
* every other cell remains unchanged.

Thus, we can write the *dV* equation for the group Z:

.. code-block:: python

   >>> Z.dV = '-V + maximum(0,1.0-(N<1.5)-(N>3.5)-(N<2.5)*(1-V))'


Finally, we iterate 4 steps in time and we check the `glider
<http://en.wikipedia.org/wiki/Glider_(Conway's_Life)>`_ has glided one step
down and right:

.. code-block:: pycon

   >>> print Z
   [[0 0 1 0]
    [1 0 1 0]
    [0 1 1 0]
    [0 0 0 0]]
   >>> for i in range(4):
           Z.compute()
   >>> print Z
   [[0 0 0 0]
    [0 0 0 1]
    [0 1 0 1]
    [0 0 1 1]]


Sources
-------

`game-of-life_dana.py <_static/game-of-life_dana.py>`_
